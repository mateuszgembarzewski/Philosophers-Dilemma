# Philosophers-Dilemma
To create this program, I used the pseudo code from chapter 6 section 6, page 281, Figure 6.13 of the the William Stallings textbook "Operating Systems Internal and Design Principals 9e".

I turned the logic presented in the pseudo code from Figure 6.13 of the textbook into C code. The logic presented uses two semaphores (one semaphore called room and another called fork) and a for loop that selects which forks are to be used and which philosophers are allowed in the room based on the threadID integer (int i in the C code). I found that in the case where threadIDs (int i) are being used to select the forks and room semaphore values inside the for loop, starvation still exists and it appears to me that there is still a race condition occuring, even with the two semaphores.

To correct this behavior, I created a new integer value labelled 'h', which increments at the end of each sequence of the while loop which it is used in. When using this h variable to select which forks are to be used and which philosophers are allowed to eat at the table, an iteration is reached where the same fork is attempted to be used twice by a philosopher. By attempting to take a fork that is already in use by another semaphore, this makes the second semaphore make the philosopher wait, this breaking the wait condition. This occurs when one of the philosphers reaches the 5th iteration of the line sem_wait(&forks[ ((i+1) % 5) ]), when in the 5th iteration (h = 5) 5 % 5 produces the value 0, thus allowing a philospher who was unable to eat because of a race condition be able to eat once.  
